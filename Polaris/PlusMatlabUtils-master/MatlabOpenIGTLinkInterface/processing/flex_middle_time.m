function [y1,xf1,xf2] = flex_middle_time(x1,x2,xi1,xi2)
%FLEX_MIDDLE_TIME neural network simulation function.
%
% Auto-generated by MATLAB, 08-Aug-2019 10:16:45.
% 
% [y1,xf1,xf2] = flex_middle_time(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 1xTS matrix, input #1
%   x2 = 3xTS matrix, input #2
%   xi1 = 1x1 matrix, initial 1 delay states for input #1.
%   xi2 = 3x1 matrix, initial 1 delay states for input #2.
% and returns:
%   y1 = 3xTS matrix, output #1
%   xf1 = 1x1 matrix, final 1 delay states for input #1.
%   xf2 = 3x1 matrix, final 1 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = 59.8362059788327;
x1_step1.gain = 0.155349197573605;
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = [0;0;0];
x2_step1.gain = [0.215308210362026;0.200743637827004;0.0897665629343387];
x2_step1.ymin = -1;

% Layer 1
b1 = [-0.84245891072043987968;-0.83292139509831542021;1.1166908313313441692;-0.20809786993248233222;-0.21622968266175177088;0.047626078313650774265;-0.67448536073525500179;-0.60203273206835805631;1.2802268598939769984;-0.068852070589319622207];
IW1_1 = [-1.1637992726688404233 0.24085055568733454434;-1.1265109977182041767 0.4229477911060645634;-0.52212193728324607367 -0.80401572556581457629;-0.038358743300886850858 0.2886050972698612771;0.88495893173561468448 0.92944731365944710522;-0.015148285025556434621 0.051268677289795998309;0.24689830679051710804 1.2525257643330334201;-0.9004066409430718787 -0.65564153070438913051;-0.2032985139884455339 -1.2751951984444087618;0.19090221400354290271 -0.30232055459643752959];
IW1_2 = [-0.14538162009905911121 -0.14310671242283662385 -0.027818108792883555064 0.012265812251113084388 0.40101228980518688338 1.2187076740156941312;0.26152996129768335543 -0.66165990869290358667 -1.2576141419169581948 -0.16662259431521012076 0.39692563942172043312 1.2168803048262863964;-0.1938294331081796551 0.52187832326671923511 -1.0918315982917308204 0.032677799156881764953 -0.67606936818729179706 0.60986417828920058692;-0.059867218908714804615 0.054223001748558805057 0.77028943500143021161 0.059462237915933607857 0.010177660764983338659 0.57083778354852265924;0.59719393142276833153 0.31570446823296538508 0.60086156893978437399 0.068502996138616489841 1.1402096545434716734 -0.32631608910041720595;-0.98901114982803262077 -0.030439905429051707098 -0.29917423017942473829 0.37124357096252563748 -0.019376472242469734014 0.10051760703234166594;0.36075422847707622198 0.56601246172288299796 0.0078202603090955693371 0.29048477213230228244 0.56817062521877048642 -0.18003907022016055195;-0.4066468271725648953 0.12962990816780911585 -0.094979742813267015178 0.2120707485884293364 0.34720301461969821366 -0.84009154831410037811;-0.12493009890567957632 0.72741316577839576496 0.44986163936411660558 -0.28358840519586109297 -0.90019288498847516156 0.58952778591447441148;0.13468934514818117765 -0.80531884063697567466 0.5689196194281073149 -0.076780249849874540602 0.48238862470772031488 -0.44036094951216009363];

% Layer 2
b2 = [0.26623796151879663974;0.050748433431350867262;-0.59255440201443754233];
LW2_1 = [-0.18899087027090516466 0.36821804575252387037 0.15512839049199253494 0.11263542632934334109 0.1365320598315891143 -1.4990156505271017284 -0.13024190100677268678 0.13274441186500618439 -0.26787605996841773459 -0.20899470173953960117;0.29161730003128250033 -0.74710283112558717455 0.40835574061170409887 -0.12047550787144623019 0.51677221227984526664 -0.37510303942464506832 -0.55528803728265541118 0.26142395481401592416 -0.89695050968968970118 -1.4818114709681318164;0.88219974023174785316 -0.86887255797883877761 -1.1282461231128815271 -1.0326001791352368286 -0.49406466938745635664 -0.13483566311374053925 0.59470864339136242371 -0.81838195204941310834 1.5140246842122604409 0.64442726541991190992];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.215308210362026;0.200743637827004;0.0897665629343387];
y1_step1.xoffset = [0;0;0];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(1,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(3,1)];

% Allocate Outputs
y1 = zeros(3,TS);

% Time loop
for ts=1:TS

      % Rotating delay state position
      xdts = mod(ts+0,2)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[0 1]-1,2)+1),2,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[0 1]-1,2)+1),6,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 1);
xits = finalxts(finalxts<=1);
xts = finalxts(finalxts>1)-1;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
