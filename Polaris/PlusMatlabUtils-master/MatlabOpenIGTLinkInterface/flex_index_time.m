function [y1,xf1,xf2] = flex_index_time(x1,x2,xi1,xi2)
%FLEX_INDEX_TIME neural network simulation function.
%
% Auto-generated by MATLAB, 29-Jul-2019 11:12:16.
% 
% [y1,xf1,xf2] = flex_index_time(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 1xTS matrix, input #1
%   x2 = 3xTS matrix, input #2
%   xi1 = 1x1 matrix, initial 1 delay states for input #1.
%   xi2 = 3x1 matrix, initial 1 delay states for input #2.
% and returns:
%   y1 = 3xTS matrix, output #1
%   xf1 = 1x1 matrix, final 1 delay states for input #1.
%   xf2 = 3x1 matrix, final 1 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = 50.4446115060186;
x1_step1.gain = 0.111926515648932;
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = [25.3760075692885;84.1637955611414;21.6775096098696];
x2_step1.gain = [0.273671106995872;0.163050844805907;0.0630007733377898];
x2_step1.ymin = -1;

% Layer 1
b1 = [0.66469710876447563042;-0.90669334035815118966;0.2723373372967584638;-0.40196397616724754975;1.5160394441671125598;-0.16929968140742623905;-0.33834279971537079001;-1.965474548957563794;-0.38608541303162813296;0.4940594375985811193];
IW1_1 = [-0.0041364767535374408203 -1.5699235039809202874;-0.3103415476067192813 -0.65948786398785930185;0.1187871786167161714 -0.27145983266107587273;0.21311628761335377202 -0.45044439814034664682;1.8192566440189423815 -0.34143430089623927337;-0.86791323525286079299 0.46093655232578850667;-0.39405804818815559631 0.94963481846859687519;-2.3500038499637798672 1.1675894991490691766;-0.022554729061441548821 0.046620257122193899113;0.76876696090377794057 -1.9077327207748597804];
IW1_2 = [-1.1292127103461513382 -1.1136992072254838781 -1.5374771080362179543 0.40976548489605119086 0.57617842991771717198 1.4288543622078229145;0.54420185026538558937 0.78713107278007898859 -0.65050679198381877733 -1.0008333959413451275 -0.24966277441835221795 1.5891722915075972011;-0.55344285561544159791 -0.092195584696078580755 -0.54672086650846130063 0.050425235537415354081 -0.0063983838522399779161 0.31417370747567824329;1.8393213781871557977 1.0522316070258110887 -2.0903711906459085945 -2.0195991476853385471 -1.0462461913893654764 1.8747923230117917726;0.29610085428665244844 0.26557254866765406254 1.5319956818384996566 -0.051276322733433798984 -0.22766912222251112219 -1.0783124161613470982;0.33981548861227034442 0.97902143058789181662 -0.64655203999447652397 0.2149951188458311957 0.36361153190663381141 1.551426599383819882;-1.4187561720910324414 -0.089729744614790010737 -0.3129246163558440097 0.14776819671012919599 0.58945779943404530421 0.63236140355961989457;0.2042175175694075917 1.3139517748442854916 -2.4218617014320003022 -0.33717441749995413769 -1.0699455089858571633 0.89264831011716472275;-0.39818142469464129496 0.64775730165102718416 0.38447385612794038323 0.6993549405044381384 -0.31309982471851771635 -1.1122498312001509735;2.3405164033199827855 0.69357692720441666001 0.57931444797294184834 -0.27671716310735439137 -1.170589562527728944 -0.61977398818492757115];

% Layer 2
b2 = [-0.28048141457120834286;1.089270039415263458;-1.2513155886427353991];
LW2_1 = [-0.40849222455825767719 0.16699543066015698489 0.27083808436595718794 -0.017337612259752877703 0.59205456876513928854 0.28156478010894198105 -1.4105563177540434427 0.27265194808166187679 -0.13102123774529261802 -0.44758283042433910648;0.25335402126957895508 -0.14572656847380727196 -1.3526830218981076293 0.75935558763152599671 -0.38352020412040083164 0.18585153739322113342 1.5092641327992428746 -0.53112324898954033081 1.5070818650200026312 0.56205182488254901152;-0.91632053983053229906 1.387893830553586394 3.0033411451655958047 -1.3651717605656437104 2.4300301049011179266 0.22872462316797692594 -2.4859799753361264685 1.2680136013000318229 -1.2380484987814410758 -1.0711446179418668834];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.273671106995872;0.163050844805907;0.0630007733377898];
y1_step1.xoffset = [25.3760075692885;84.1637955611414;21.6775096098696];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(1,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(3,1)];

% Allocate Outputs
y1 = zeros(3,TS);

% Time loop
for ts=1:TS

      % Rotating delay state position
      xdts = mod(ts+0,2)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[0 1]-1,2)+1),2,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[0 1]-1,2)+1),6,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 1);
xits = finalxts(finalxts<=1);
xts = finalxts(finalxts>1)-1;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
