function [y1,xf1,xf2] = flex_middle_time(x1,x2,xi1,xi2)
%FLEX_MIDDLE_TIME neural network simulation function.
%
% Auto-generated by MATLAB, 25-Jul-2019 20:35:13.
% 
% [y1,xf1,xf2] = flex_middle_time(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 1xTS matrix, input #1
%   x2 = 3xTS matrix, input #2
%   xi1 = 1x1 matrix, initial 1 delay states for input #1.
%   xi2 = 3x1 matrix, initial 1 delay states for input #2.
% and returns:
%   y1 = 3xTS matrix, output #1
%   xf1 = 1x1 matrix, final 1 delay states for input #1.
%   xf2 = 3x1 matrix, final 1 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = 61.5186524756864;
x1_step1.gain = 0.190907655755773;
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = [3.25268069154369;71.9415123157788;6.92316888754443];
x2_step1.gain = [0.141012435688913;0.094505361403206;0.0532231090441924];
x2_step1.ymin = -1;

% Layer 1
b1 = [-0.50404284098371898715;-0.02584985149253497122;-0.51575110673689705809;-1.3623302891605066911;-1.3605058133303484791;-0.032976904800042776411;-0.82869515843420271661;0.45777075942867789804;0.72767834480044490952;-0.12501190666395911588];
IW1_1 = [-0.91785411375026293435 -1.3051082213871734172;0.13415920934165911915 0.033573443655307302902;-0.8573252194159445283 -0.076021010407569547529;-0.67289367927387389035 -0.28216365391844111521;0.44577782695740109098 -1.5011176235279135582;-1.6860028910538502611 1.5231941242380675483;0.51615646272199988687 -1.9388563643736269615;1.0901721770193832928 -0.21188104027886062175;-0.83961290013394274112 0.65667379963134497878;-0.96285068111066229868 -2.3158313239617731583];
IW1_2 = [0.24427628661321165726 -0.14658856502047840076 1.0471553214134001752 0.64928824565948273229 0.11803903944879456933 -0.99813704136255687605;1.2192781163432888647 -0.07654461927068909044 0.20846287323440321204 -0.4427501996657922656 -0.026699743306287621741 -0.0089754537075222087794;-0.1559197788520722272 -0.19896768408257201055 -0.10950724972958061909 0.19157699245668349808 0.15154403303803140601 0.10061991019265666136;0.76879305090129490541 -0.17862211967344776564 -0.44087081491111407283 2.6660661762615549542 0.86717802522801856746 0.073541421603664253182;-1.2559140822133685322 2.0641416494818920491 0.96264131125215823825 0.65768559494118961073 -0.39377512716691853711 -0.24878558903641251332;0.99178582328539965918 -0.50425959089224992038 -3.139299573676611832 -0.69997617790362176571 -0.42722856251792662441 2.2910443901942745271;-0.79451563918049061819 1.0370821085062211786 1.0629623860242802813 0.37171266685165427202 0.22215541807061095492 -0.41015523860938635226;-0.10105851036273350019 0.31074003553632995045 0.1666530243449980131 0.011280371693768390801 0.068502315953540088289 -0.83294317051703159471;0.279511939636933604 0.77193567770528193073 -0.00935899643803790246 -0.29120825717618431527 -0.30105754029059794696 -0.15208040853139950799;1.5240290775020708391 -0.73532042128000418835 2.2365063122526978034 -0.61673399289114949617 0.090947194260360297857 -1.5418205273753102791];

% Layer 2
b2 = [0.22719700345482746195;-0.37896466728619565556;-0.43392920338231183441];
LW2_1 = [-0.65396403625807153492 1.2771054052031993731 0.8754849960608798165 0.1669388975245853779 0.33414605144462355968 0.20872889902584171318 -0.19410282555827729212 0.51136605672430524017 0.11507964629115552402 0.32029139352611846192;-0.46389407647984021166 0.22777919964154680343 0.35493566007979410193 0.11741736153117478259 0.91401522524268619119 0.073300117336452225159 -0.66349210067219333009 0.50293599284824086482 1.4976601049481150785 0.28686748837301334625;1.8644258208495805285 0.050455489968279913782 -2.1814211549703439452 -0.43195587678845781543 -1.190215426841325197 -0.5271102216464392809 1.1750356289922643249 -1.3490795874298242563 -0.13500586073612735882 -1.1746793768400212166];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.141012435688913;0.094505361403206;0.0532231090441924];
y1_step1.xoffset = [3.25268069154369;71.9415123157788;6.92316888754443];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(1,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(3,1)];

% Allocate Outputs
y1 = zeros(3,TS);

% Time loop
for ts=1:TS

      % Rotating delay state position
      xdts = mod(ts+0,2)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[0 1]-1,2)+1),2,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[0 1]-1,2)+1),6,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 1);
xits = finalxts(finalxts<=1);
xts = finalxts(finalxts>1)-1;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
