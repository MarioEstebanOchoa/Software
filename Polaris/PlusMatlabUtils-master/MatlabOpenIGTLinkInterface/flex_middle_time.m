function [y1,xf1,xf2] = flex_middle_time(x1,x2,xi1,xi2)
%FLEX_MIDDLE_TIME neural network simulation function.
%
% Auto-generated by MATLAB, 26-Jul-2019 16:45:13.
% 
% [y1,xf1,xf2] = flex_middle_time(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 1xTS matrix, input #1
%   x2 = 3xTS matrix, input #2
%   xi1 = 1x1 matrix, initial 1 delay states for input #1.
%   xi2 = 3x1 matrix, initial 1 delay states for input #2.
% and returns:
%   y1 = 3xTS matrix, output #1
%   xf1 = 1x1 matrix, final 1 delay states for input #1.
%   xf2 = 3x1 matrix, final 1 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = 63.7686290805757;
x1_step1.gain = 0.180004641181732;
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = [6.4874392649439;81.1218585119757;31.820561970737];
x2_step1.gain = [0.21791678561312;0.186550514511889;0.0655369677280064];
x2_step1.ymin = -1;

% Layer 1
b1 = [-0.18004348354165222723;-0.10301230006568694308;-0.20407842470258705236;-0.020829030049749456405;2.1361263190552577385;-0.14585327299312886296;-0.016733541526750266015;-0.27695340015224001462;-0.1918807201367374593;1.3096614367124386202];
IW1_1 = [-0.53213778342950468492 1.1999831798492479606;-0.70598495804812189114 0.059470612128604702362;-1.293781252371434265 0.9396889088662152556;0.17268181646368363502 -0.26920696261824844653;-0.10973988350277052994 -1.3625648836602575198;-2.0031752982264259266 0.80986235541614326472;0.69627503342854524249 -1.0367102236735452614;0.16977273675799248176 -0.51167035253308379428;-0.21127081821138807283 0.33070638078488912015;1.433914731072480242 0.2814310812148967389];
IW1_2 = [0.34049946661482688448 1.8798902200379523642 -0.46507198779407754596 0.27693607144641102513 -1.0121989418192507415 -0.042827304719344587436;1.4085043579773877109 -3.7356309621025962642 -3.1461267043524223652 -1.5635650406343861718 3.4233489917569577266 3.9373170479997692262;1.5092124163206335208 -0.9361450397120909539 0.6164794366375154766 -0.60357082737322009791 0.90489538462289587084 -0.031558077206524731695;1.8467352188987036232 -3.7048045977441228516 -4.7511697494201143854 -1.9745797643332891891 3.3057951468027879649 5.021025584766058536;-1.6190579914557596819 -2.5592766761635123984 2.0523396223163903329 1.4621745375750105911 -0.076578383941400235413 2.2520601943462019712;-0.028880903237789395249 -3.0570584251922423569 -0.29734572010574866763 -0.30912645001124816613 2.7741583964565315057 1.5122808399713698613;1.1255028764576393563 0.50598518722795138292 0.55218427573282158338 -0.50083716303095549005 -0.45981674139462813677 -0.045944444006299739458;1.2523558455353711594 1.7016720917105616628 0.43071431214615363281 -0.61375417259120323976 -0.91399944211177008846 0.093346085048883448154;1.0902969860709432748 -0.15765617424370745314 0.50320312456140681157 -0.25029942093205592712 0.048119723385673787708 -0.18165115925368313654;-0.1071707745823261837 0.89338867633417229364 -2.4453141446546053928 -1.0839168773922742695 0.38034392462492766507 1.4152685191966529743];

% Layer 2
b2 = [0.12294737389191603971;0.13837014819592682868;0.21598246594601372417];
LW2_1 = [0.46650244585915018325 -1.421018750012299714 0.93676992854835450242 1.0226534846026436032 -0.1375102580532938934 0.43209416766741148841 1.2452805100732180499 -0.53170363121586805555 -0.49978014363460460112 -0.10406400635853403636;0.2362504791985284569 1.7733046373153131814 0.11642615506620325461 -1.1644844153223603556 -0.011868733578561024844 -0.92975050089701483103 -0.48737224497317116478 0.62913592839761678377 -0.54048653102826804684 0.15301366336869084983;-1.4090779256974590439 3.3306540138225484426 -1.3673053179000982382 -2.3094069907560434984 0.22213532879663977493 -1.4223939439912218763 -2.6265664307655365306 1.5809197878494616329 2.9410457636726778929 0.38022987454882489766];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.21791678561312;0.186550514511889;0.0655369677280064];
y1_step1.xoffset = [6.4874392649439;81.1218585119757;31.820561970737];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(1,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(3,1)];

% Allocate Outputs
y1 = zeros(3,TS);

% Time loop
for ts=1:TS

      % Rotating delay state position
      xdts = mod(ts+0,2)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[0 1]-1,2)+1),2,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[0 1]-1,2)+1),6,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 1);
xits = finalxts(finalxts<=1);
xts = finalxts(finalxts>1)-1;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
