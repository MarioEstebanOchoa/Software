function [y1,xf1,xf2] = imu_index_model(x1,x2,xi1,xi2)
%IMU_INDEX_MODEL neural network simulation function.
%
% Auto-generated by MATLAB, 13-Aug-2019 18:06:08.
% 
% [y1,xf1,xf2] = imu_index_model(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 3xTS matrix, input #1
%   x2 = 3xTS matrix, input #2
%   xi1 = 3x2 matrix, initial 2 delay states for input #1.
%   xi2 = 3x2 matrix, initial 2 delay states for input #2.
% and returns:
%   y1 = 3xTS matrix, output #1
%   xf1 = 3x2 matrix, final 2 delay states for input #1.
%   xf2 = 3x2 matrix, final 2 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-40.3144799286017;2.10083082171966;14.0099171449053];
x1_step1.gain = [0.269108764995688;0.296619205564516;0.41564856113095];
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = [0.00139812072630008;0;0];
x2_step1.gain = [0.289722417851358;0.2048104608665;0.187769089490464];
x2_step1.ymin = -1;

% Layer 1
b1 = [-0.094939283759967088572;-0.058938718059195274734;-0.043082893325670418294];
IW1_1 = [0.13672736334143706372 0.075473207980920983817 -0.039453622098992245648 -0.14453100436316873578 -0.061387892636447102812 0.037766951769586831755;0.15035454813509369076 -0.4640645242006823934 0.31222871097034626819 -0.12589863915203255984 0.41350422201307585057 -0.32402147390375179992;0.18200520090544075602 0.5341478127839628387 -0.16029533692143063672 -0.18786467321317568135 -0.47338761811163904136 0.1618082216883487412];
IW1_2 = [-0.57250628640031109295 0.091205036656994253885 0.099543404165470958378 0.17677903364362443361 -0.028719443082898851727 -0.025499813103230371814;0.50772274056499366868 1.5717968554910999313 0.87115221360207550916 -0.26139893170814132439 -0.63627555103058242025 -0.38530031798551489519;0.41188302203235360732 -0.1042746326436985449 1.0761667758475481627 -0.16336120133701390045 0.03661430509332991301 -0.33443117270438960098];

% Layer 2
b2 = [-0.18479469069623696842;0.1001773323256776177;0.14038785631164715784];
LW2_1 = [-2.2913883846220546303 0.16779548536780344858 0.13430343154874452294;0.36506405278838183204 1.0143093032139747223 -0.69864834717410484455;0.71716022225196307538 -0.014385155696972278666 1.1560376022587999234];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.289722417851358;0.2048104608665;0.187769089490464];
y1_step1.xoffset = [0.00139812072630008;0;0];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(3,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(3,1)];

% Allocate Outputs
y1 = zeros(3,TS);

% Time loop
for ts=1:TS

      % Rotating delay state position
      xdts = mod(ts+1,3)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[1 2]-1,3)+1),6,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[1 2]-1,3)+1),6,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
