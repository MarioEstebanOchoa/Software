function [y1,xf1,xf2] = index_bm_nnm_exp3(x1,x2,xi1,xi2)
%INDEX_BM_NNM_EXP3 neural network simulation function.
%
% Auto-generated by MATLAB, 13-Sep-2019 15:02:05.
% 
% [y1,xf1,xf2] = index_bm_nnm_exp3(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 5xTS matrix, input #1
%   x2 = 3xTS matrix, input #2
%   xi1 = 5x2 matrix, initial 2 delay states for input #1.
%   xi2 = 3x2 matrix, initial 2 delay states for input #2.
% and returns:
%   y1 = 3xTS matrix, output #1
%   xf1 = 5x2 matrix, final 2 delay states for input #1.
%   xf2 = 3x2 matrix, final 2 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-0.395963890646992;-0.25167455871334;-0.179220806703439;-0.218505017539669;-0.0846359555503016];
x1_step1.gain = [2.46688656815633;3.4585985335771;5.42321823082988;5.28904699348167;5.88996910229881];
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = [-29.69847451;-53.08714143;-33.15052065];
x2_step1.gain = [0.0215259017867669;0.0437499215793593;0.0404677022966254];
x2_step1.ymin = -1;

% Layer 1
b1 = [-0.29058436004889154347;0.055132920634728972697;0.10822678699872299857;-0.15154032411829512772;-0.031850703501271233897];
IW1_1 = [-0.14660345601353458322 0.020253014487356189866 -0.23623853874366132488 -0.1094453536830440471 -0.078318404362911223093 -0.16145444876562325964 -0.14545348084671000377 0.69572703522532841625 0.55939582493421668996 0.27563675287501626654;-0.10149810743674009261 1.4359537639342347948 -0.13514231281542299357 0.83985609879833045266 0.67308136427294162907 -0.23420416003670690985 -1.0780743531408827351 0.10408682658402142185 -0.91914011285950381058 -0.7942082209089473821;0.0073753322417144254533 -0.35662033778002050211 0.050304655371072683201 -0.21652118654921739815 -0.17356143898167553097 0.058633136189910201042 0.27610208592476909173 0.062057615625977807783 0.3117870763235413567 0.24250365396335096801;-0.095035023959476036537 0.99182008556749390316 -0.17118620420958191586 0.50039137743242079193 0.45232581914045244531 -0.24589480728715779057 -0.84387897890660878986 0.41277950996646090021 -0.33483160863060767998 -0.40119007031044190414;0.23268422200881325179 -0.013535495512819163688 0.18406199839272752161 0.025022626717207469699 0.066899133923755293996 0.17969283220903303766 0.15471367723087231516 -0.76350689526809045748 -0.63230652184851998676 -0.28217160489216380759];
IW1_2 = [-1.0526391654643756368 1.0688933069360728734 0.58933344030933287883 1.5883284959497034894 -0.7527443422073178958 0.0084089054762797425802;-0.22396971767681117527 0.40024376661848198866 1.1501007040441735274 1.2998888695001098448 0.13583044288734916205 -0.6723149694516470376;-0.17803339690100486448 -0.43069446507697783932 -0.59143401996122990649 -0.10972323057997393492 0.021067329733465860186 0.24658399397215827187;-1.8988942317079415822 0.83772622410125097137 0.43697309582059373767 2.1762204302234549047 -0.40904948084943071329 -0.22070250079932651754;0.54522772836592736656 -0.10168357649593338932 -2.1373937223284853459 -1.5637899780534698646 0.41446864046347653421 0.8006101032637997772];

% Layer 2
b2 = [-0.11161673646126996085;0.45823984590169386522;0.0116436703588138242];
LW2_1 = [1.4358676244206096673 1.5196081446976250628 1.4080410772647196094 -1.9689711608719493441 0.55286527611374580715;1.2973939401942009564 -0.094893866534560208925 -0.97975864617211760876 -0.14115922704812874922 0.8477967593491406717;-1.1788298416299778371 -1.0359368364844372401 -2.1386502631395098994 0.67262408685492691696 -1.0553362036887057318];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.0215259017867669;0.0437499215793593;0.0404677022966254];
y1_step1.xoffset = [-29.69847451;-53.08714143;-33.15052065];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(5,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(3,1)];

% Allocate Outputs
y1 = zeros(3,TS);

% Time loop
for ts=1:TS

      % Rotating delay state position
      xdts = mod(ts+1,3)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[1 2]-1,3)+1),10,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[1 2]-1,3)+1),6,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
