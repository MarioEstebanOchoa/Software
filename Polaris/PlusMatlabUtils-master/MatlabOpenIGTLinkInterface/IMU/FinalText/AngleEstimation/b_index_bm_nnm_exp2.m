function [y1,xf1,xf2] = index_bm_nnm_exp2(x1,x2,xi1,xi2)
%INDEX_BM_NNM_EXP2 neural network simulation function.
%
% Auto-generated by MATLAB, 13-Sep-2019 14:54:48.
% 
% [y1,xf1,xf2] = index_bm_nnm_exp2(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 5xTS matrix, input #1
%   x2 = 3xTS matrix, input #2
%   xi1 = 5x2 matrix, initial 2 delay states for input #1.
%   xi2 = 3x2 matrix, initial 2 delay states for input #2.
% and returns:
%   y1 = 3xTS matrix, output #1
%   xf1 = 5x2 matrix, final 2 delay states for input #1.
%   xf2 = 3x2 matrix, final 2 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-0.241753377008813;-0.158337665927102;-0.135378987874504;-0.121942893948542;-0.0913658003264785];
x1_step1.gain = [3.71106274030943;5.97553294299989;4.77121123819471;6.65785661154676;10.6407519071246];
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = [-29.69847451;-53.08714143;-33.15052065];
x2_step1.gain = [0.0215259017867669;0.0437499215793593;0.0404677022966254];
x2_step1.ymin = -1;

% Layer 1
b1 = [-0.23979345861012438257;-0.05454636231337452873;-0.030332990091570154884;0.14112635482088312089;0.1394198762392520885];
IW1_1 = [0.01739012089282497564 0.13423590598045448408 0.27501352390839145512 -0.60106608130044913985 0.48073317371534818321 0.0055737064275109497041 -0.11151818265438553923 -0.29994519083249254754 0.86112380002820410052 -0.47085640851511356697;0.053901576311453154589 0.14396664947364701259 0.029173653532221399676 0.12946417617511507547 -0.15926682543830913974 -0.070319177444830155421 -0.1075378012696199953 -0.021608833903667867132 -0.20945442174419176551 0.15530452855711457394;0.30513983840594099961 0.57265500844673467018 0.38592939772497569795 0.2666190533331777579 -0.53744343338960121059 -0.40046743782151722479 -0.51431983403080372419 -0.33734114025729372566 -0.45792685838375685181 0.57447962486413017835;0.30959484314346202849 0.8389389600572899619 0.64878845241774008024 -0.69443740529315090004 0.1360067929632581829 -0.31460778433750452576 -0.75596340720130872359 -0.65881341399909099099 0.88570981640872470386 -0.095425723901187822773;-0.29376129819983493041 -0.525971819156742737 -0.29339953311272432002 -0.29537773400037276028 0.41947165445951117846 0.38479692539577414756 0.49050200131845717033 0.27355120790576642476 0.42252765722845864182 -0.44663643499321187269];
IW1_2 = [-0.51715967495242176621 0.91181913318068308349 0.27371889094495305272 0.19507427838307139778 -0.25286535139865906618 -0.36429169433862390592;-0.51550075739099332495 -0.3757755497613775586 -0.86578860668478652141 0.36513496730461941775 0.035862861339031042174 0.21963623032446971672;-1.078592348344210583 0.59048531001825199649 0.49513069335188086839 1.6464025792945606863 -0.37273524588783490952 -0.39860709212128286882;-1.6584104683147120607 -0.15923024992689888135 1.8202246157738972698 1.5276859381789158476 0.047623713454195359951 -1.5266349880173333275;1.8449733381724524595 -0.7464611206472702154 -0.017746345024608280866 -1.7166057005679695724 0.47959409503650013429 0.17984335854899893836];

% Layer 2
b2 = [-0.01528370806576913668;0.29894785404531010187;-0.236628806651065976];
LW2_1 = [0.53878494893570916258 0.56083317770226281951 1.5555597012250728106 -0.37772322214670861484 1.917798084785898638;0.79520849716397834506 -0.52094128387313631823 0.26114764076632662748 -0.71403341463236325026 -0.50429415817941036781;-0.78548628177453394539 -1.4951323354663799137 -0.51546549946619757421 0.51902933305550857934 -0.59749984703667113894];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.0215259017867669;0.0437499215793593;0.0404677022966254];
y1_step1.xoffset = [-29.69847451;-53.08714143;-33.15052065];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(5,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(3,1)];

% Allocate Outputs
y1 = zeros(3,TS);

% Time loop
for ts=1:TS

      % Rotating delay state position
      xdts = mod(ts+1,3)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[1 2]-1,3)+1),10,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[1 2]-1,3)+1),6,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
