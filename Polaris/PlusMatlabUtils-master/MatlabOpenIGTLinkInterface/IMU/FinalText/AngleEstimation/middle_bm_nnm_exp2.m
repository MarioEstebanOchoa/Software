function [y1,xf1,xf2] = middle_bm_nnm_exp2(x1,x2,xi1,xi2)
%MIDDLE_BM_NNM_EXP2 neural network simulation function.
%
% Auto-generated by MATLAB, 13-Sep-2019 14:55:32.
% 
% [y1,xf1,xf2] = middle_bm_nnm_exp2(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 4xTS matrix, input #1
%   x2 = 3xTS matrix, input #2
%   xi1 = 4x2 matrix, initial 2 delay states for input #1.
%   xi2 = 3x2 matrix, initial 2 delay states for input #2.
% and returns:
%   y1 = 3xTS matrix, output #1
%   xf1 = 4x2 matrix, final 2 delay states for input #1.
%   xf2 = 3x2 matrix, final 2 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-0.280670768920793;-0.197285173680976;-0.095713331755221;-0.091292338943629];
x1_step1.gain = [3.73961925724051;5.86224493672438;9.64016416728728;12.5337867344187];
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = [-34.05729511;-56.20691974;-10.00403908];
x2_step1.gain = [0.0211267846895733;0.0395706711489379;0.0871775967713017];
x2_step1.ymin = -1;

% Layer 1
b1 = [0.0007108053195811924645;0.046202618147612437016;-0.22690081429213795894;-0.044158763365188972994;-0.016263755637212235633];
IW1_1 = [-0.24299116257158678844 0.81580533264773236191 0.26387476361742118192 0.20941663641356189629 0.44751880627205958829 -0.68988929388112141261 -0.31817675809729811798 -0.061845521059864065616;-0.026146880060561518422 0.16240087450397125424 0.17048376748477556131 0.13675950384480514699 -0.14446817229656150339 -0.10200895090594438996 -0.13430459737737343584 -0.34640695928364162448;0.49768361561507762358 0.0084442900004385607754 -0.22570940779055531644 -0.57311384404006815441 0.046721725141862166519 -0.13218450508502230245 0.14467596108079391892 1.2334020371109730707;0.057306553414842767435 -0.53542421457128408502 -0.1179886495725086526 -0.11906752590350790089 -0.31795426920330244203 0.42999639811795170585 0.19742093520021306019 -0.056325059755094837588;0.21477281807754602938 -0.069243472242735346067 -0.16386737958074673593 -0.23543564194372743059 0.0046574044559048429284 0.0090490601312789610555 0.12727377710582252202 0.48001888609518345019];
IW1_2 = [-2.9203310441271312925 0.25692449248050142074 -0.05247831819016722521 2.7163170108740763986 -0.14386819316783136524 0.21891789878253639645;0.13583474451694757534 -0.80227807196603062589 -0.43352345953017712432 0.22802625734882600583 0.38292108596261781317 0.3241264852618975234;0.18137181961272380581 1.4461977508742094312 -0.48207590179000825437 -0.91882064941808849756 -1.0272427953054295013 -0.37949684137575795395;1.2734180948207369788 0.14111896382650823689 -0.60899542410365625766 -1.448044342796248829 -0.055108847122680444663 0.2001145131772834318;-0.16812073101002625308 0.12878831562299397628 0.2804368170287491191 -0.45292371683364140988 -0.19677743288584845227 -0.39703551613815679655];

% Layer 2
b2 = [0.027148879107450934328;0.10980591649975465773;-0.11845499268963435857];
LW2_1 = [-1.0488341473230602396 0.18965927275290603293 0.54034953875266478196 -1.0621842744882652454 -1.4184143845775065707;0.31567153820711640888 -1.5723922814196604758 0.072697721903776074681 0.6916711347838401247 -1.3958309024655093378;-0.53812646653832696408 -1.265630304671830908 -0.74465535276348593374 -0.80467964462780594559 0.52815410214381164344];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.0211267846895733;0.0395706711489379;0.0871775967713017];
y1_step1.xoffset = [-34.05729511;-56.20691974;-10.00403908];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(4,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(3,1)];

% Allocate Outputs
y1 = zeros(3,TS);

% Time loop
for ts=1:TS

      % Rotating delay state position
      xdts = mod(ts+1,3)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[1 2]-1,3)+1),8,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[1 2]-1,3)+1),6,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
