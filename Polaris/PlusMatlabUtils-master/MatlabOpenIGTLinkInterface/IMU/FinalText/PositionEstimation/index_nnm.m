function [y1,xf1,xf2] = index_nnm(x1,x2,xi1,xi2)
%INDEX_NNM neural network simulation function.
%
% Auto-generated by MATLAB, 27-Aug-2019 00:46:04.
% 
% [y1,xf1,xf2] = index_nnm(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 4xTS matrix, input #1
%   x2 = 3xTS matrix, input #2
%   xi1 = 4x2 matrix, initial 2 delay states for input #1.
%   xi2 = 3x2 matrix, initial 2 delay states for input #2.
% and returns:
%   y1 = 3xTS matrix, output #1
%   xf1 = 4x2 matrix, final 2 delay states for input #1.
%   xf2 = 3x2 matrix, final 2 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [0.0211;0.3549;-0.1637;0.0211];
x1_step1.gain = [11.6346713205352;18.001800180018;16.9779286926995;10.5318588730911];
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = [0;0;0];
x2_step1.gain = [0.436077815626022;0.206377866957878;0.322142998953933];
x2_step1.ymin = -1;

% Layer 1
b1 = [7.6160017958389471075e-05;0.21176509340474336529;0.17426736962288852384];
IW1_1 = [0.17653087673084061349 -0.15272747692284072141 -0.19988037278455686452 0.015893731765800302863 -0.019935260020125664809 0.012074641662700972763 0.0328501296725678682 -0.029182247741129253155;0.73117328373735501756 -0.20254582235976315019 -0.58217626589197402076 -0.44357957762436556193 -0.26141346252240788006 -0.095056611093597323525 0.012580133778714771772 0.032092059345748429056;0.5519529683735683312 -0.23053822895391964942 -0.079733659960251751508 -0.26020814937785141652 -0.39416456217853518273 0.12201042230692217549 -0.090501587544045067335 0.14296855147815776266];
IW1_2 = [-0.4424240783101058283 -0.46166835517254845023 -0.12577354951687050311 -0.015091727850458102472 0.015553189544488473656 -0.010823310690729613312;0.36855241017763296085 -0.28087241166793380787 0.30806199500680725434 0.054499889893361547211 0.032500103403556794557 -0.020116851164810246877;-0.39842792348133870828 0.22717243149386245893 0.47006538266405678561 0.021715532674654865891 0.062991345921306049482 0.012563911739548141999];

% Layer 2
b2 = [0.0081667476132827078461;0.026771678288859984685;-0.20953781346357819304];
LW2_1 = [-0.73778932340534930656 0.78087089173606694104 -0.7551975513522649619;-0.79806897658476882995 -0.90096398459846638307 0.38916830018068565566;-0.3441761339428042743 0.7874422561574302426 1.0933380995947190595];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.436077815626022;0.206377866957878;0.322142998953933];
y1_step1.xoffset = [0;0;0];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(4,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(3,1)];

% Allocate Outputs
y1 = zeros(3,TS);

% Time loop
for ts=1:TS

      % Rotating delay state position
      xdts = mod(ts+1,3)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[1 2]-1,3)+1),8,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[1 2]-1,3)+1),6,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
