function [y1,xf1,xf2] = imu_thumb2_model(x1,x2,xi1,xi2)
%IMU_THUMB2_MODEL neural network simulation function.
%
% Auto-generated by MATLAB, 13-Aug-2019 18:18:17.
% 
% [y1,xf1,xf2] = imu_thumb2_model(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 6xTS matrix, input #1
%   x2 = 3xTS matrix, input #2
%   xi1 = 6x2 matrix, initial 2 delay states for input #1.
%   xi2 = 3x2 matrix, initial 2 delay states for input #2.
% and returns:
%   y1 = 3xTS matrix, output #1
%   xf1 = 6x2 matrix, final 2 delay states for input #1.
%   xf2 = 3x2 matrix, final 2 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-30.7567157484679;-35.4266175003306;27.9010400689877;-28.0882337405785;-14.5412758190209;-26.6940489010155];
x1_step1.gain = [0.102959720023148;0.108759321537454;0.157286383535318;0.0610774975514393;0.218976220462129;0.0953362700977042];
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = [0;0;0];
x2_step1.gain = [0.078398395366927;0.162343260450646;0.122613055640241];
x2_step1.ymin = -1;

% Layer 1
b1 = [-0.023757132308529081005;-0.61182550910743094263;-0.086324039026379056905];
IW1_1 = [-0.055347564008667984869 -0.10103150633553382998 -0.069340255863582611617 0.023176294710685753364 -0.0025689410056387918836 0.053004278165828935809 0.046619572055314389969 0.087976672334523650654 0.032604956254637530721 -0.033243033975933457269 0.00066598525584034165645 -0.070277293036452873065;-0.029448210861930272653 -0.073807205942319001335 -0.11323435050721404604 -0.13136332269092948488 0.042249407240834709054 -0.22135382781966519983 -0.010340014164479853151 0.049279183562073350378 0.058333919860524947876 0.079067748984592955974 -0.017915977507986922956 0.16063035681490062112;-0.1271153019421775443 0.16820958986618320119 -0.052000023547334302265 -0.019527076784482871874 0.01739273010893887042 0.054888844746510644101 0.1092077926140666011 -0.14981780165931268822 0.046916017862654271764 8.6440328918441276893e-05 -0.019693019396836656393 -0.05499440452716291422];
IW1_2 = [0.28015932612866245588 -0.77659314697759551649 0.19574269410914210687 -0.10942892985164076602 0.22040038907965131543 -0.027858445833323655649;0.8643418249925143293 0.92754608833265239642 -0.11548302188887592246 -0.31422656725815412138 -0.19638606512424197637 -0.041184300072941902593;0.23705985201955737107 -0.13630706951999152499 0.89814891960635456769 -0.066326221360851159159 0.013962356538117710533 -0.19938737339360756984];

% Layer 2
b2 = [0.7154648383466586381;0.20525126528278245241;-0.031990224518104078133];
LW2_1 = [1.6008878750155115522 1.2356564974403678736 -0.17062405036983019357;-1.502532652713303829 0.36780504113102469033 0.40743003682401834897;-0.68402933393869447265 -0.23234326534277405241 1.4703122322367205843];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.078398395366927;0.162343260450646;0.122613055640241];
y1_step1.xoffset = [0;0;0];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(6,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(3,1)];

% Allocate Outputs
y1 = zeros(3,TS);

% Time loop
for ts=1:TS

      % Rotating delay state position
      xdts = mod(ts+1,3)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[1 2]-1,3)+1),12,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[1 2]-1,3)+1),6,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
