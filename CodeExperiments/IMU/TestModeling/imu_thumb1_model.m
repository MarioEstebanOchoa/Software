function [y1,xf1,xf2] = imu_thumb1_model(x1,x2,xi1,xi2)
%IMU_THUMB1_MODEL neural network simulation function.
%
% Auto-generated by MATLAB, 13-Aug-2019 18:16:22.
% 
% [y1,xf1,xf2] = imu_thumb1_model(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 6xTS matrix, input #1
%   x2 = 3xTS matrix, input #2
%   xi1 = 6x2 matrix, initial 2 delay states for input #1.
%   xi2 = 3x2 matrix, initial 2 delay states for input #2.
% and returns:
%   y1 = 3xTS matrix, output #1
%   xf1 = 6x2 matrix, final 2 delay states for input #1.
%   xf2 = 3x2 matrix, final 2 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-38.0348129818984;-37.2399403843159;-22.342930113257;-23.7008740126721;9.70392713347758;-23.2074986905313];
x1_step1.gain = [0.11214072723293;0.113049117402383;0.0845106717536439;0.109431150869427;0.12259959822615;0.0408288719550837];
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = [0;0;0];
x2_step1.gain = [0.0447935251921758;0.140432692597265;0.106721449115078];
x2_step1.ymin = -1;

% Layer 1
b1 = [-0.20687684286729482452;-0.0010369326252619957829;0.11879587939921253115];
IW1_1 = [-0.13698977991332847437 0.21014884332991290439 -0.099076940931721882433 -0.07683444536549734194 0.074991751876691034595 -0.018303070941150759166 0.14795374000346225851 -0.22481725211167749579 0.088856261635616801131 0.091744620545605337636 -0.079261182859760290209 -0.011443534718884419005;-0.025319730790713871477 -0.15994280589366050016 -0.10928171379931722607 0.037533094936200196712 -0.034493407295818595548 -0.029879768053180596338 -0.011585499456708494778 0.1920169508947784931 0.12460135472391360711 -0.047506425265144390513 0.026950780081332413596 0.07102168869109805327;-0.036733929908896227612 -0.41816432917667711866 -0.14880063022742756607 -0.001438445721629284758 -0.10208293880339383564 0.019972876061633129674 0.053794339003796758092 0.40109078701923400745 0.10625310753335073799 -0.018411660294719554148 0.09491020556564824795 0.014454684825168307577];
IW1_2 = [0.56352844812366065241 1.6363596895880854198 0.50676800012248790495 0.1475102314613362664 -0.39294392663831018142 0.11640434126135879023;0.073905118794925450665 -1.1730456676521985315 0.66704758534980124196 -0.17818458267754980207 0.39940681364349278626 -0.44720205663109979799;0.51068545477245275155 -0.71251386671527783268 -0.83309877837176093962 -0.29499998209762312573 0.19255414512392107773 0.20453570468918491621];

% Layer 2
b2 = [0.091688430122742872741;0.057827778762478528052;0.11761085756132654001];
LW2_1 = [0.99927360736551695819 0.91545746075623735116 1.2766556229718364346;-0.00108224938771576463 -1.0713446269775870334 -0.39115221016298451495;0.45396285957378595954 1.1595607749862479885 -0.65582008847065009771];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.0447935251921758;0.140432692597265;0.106721449115078];
y1_step1.xoffset = [0;0;0];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(6,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(3,1)];

% Allocate Outputs
y1 = zeros(3,TS);

% Time loop
for ts=1:TS

      % Rotating delay state position
      xdts = mod(ts+1,3)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[1 2]-1,3)+1),12,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[1 2]-1,3)+1),6,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
