function [y1,xf1,xf2] = middle_bm_nnm_exp1(x1,x2,xi1,xi2)
%MIDDLE_BM_NNM_EXP1 neural network simulation function.
%
% Auto-generated by MATLAB, 19-Sep-2019 16:58:14.
% 
% [y1,xf1,xf2] = middle_bm_nnm_exp1(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 3xTS matrix, input #1
%   x2 = 3xTS matrix, input #2
%   xi1 = 3x2 matrix, initial 2 delay states for input #1.
%   xi2 = 3x2 matrix, initial 2 delay states for input #2.
% and returns:
%   y1 = 3xTS matrix, output #1
%   xf1 = 3x2 matrix, final 2 delay states for input #1.
%   xf2 = 3x2 matrix, final 2 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-0.408452786999554;-0.263333821349932;-0.139058055166765];
x1_step1.gain = [2.37715946826089;4.07217099049612;6.85986423641121];
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = [-34.05729511;-56.20691974;-10.00403908];
x2_step1.gain = [0.0211267846895733;0.0395706711489379;0.0871775967713017];
x2_step1.ymin = -1;

% Layer 1
b1 = [-0.22093003982785139327;0.047151688358150575797;-0.10421305099650556014;0.0570139221010582814;-0.022637663324333461706];
IW1_1 = [-0.60471084275635678118 0.86131201149078939761 0.48013704158792719356 -0.252483434758678571 -0.20816589388068298949 -0.28764493709155536383;0.13802105742361001073 -1.0650711097237965941 -0.062406702131951007073 -0.92631484206856573582 0.1694476938220021156 0.11394420618078421326;0.059425301420111854844 0.22845505285556011454 0.065136514966933498072 -0.032280635559269535428 -0.0070389298973087370548 -0.053285681713617999433;-0.35226610783973971719 1.1693122688108259499 0.35783431783830088602 0.52059071981924698314 -0.28105580806817126449 -0.30240627146653464852;-0.10049600210136661049 0.58245622615881298412 0.13201781374343246611 0.12183450132289432022 -0.082305733810506515047 -0.077571921513788763547];
IW1_2 = [2.7227124169750047677 0.54640550508892982151 0.67727431746444244354 -1.9107340233908032268 0.33250245721547277977 -0.42232656775835936136;0.6857213368111716445 -0.64858150090812383137 -0.056623271236253776284 -0.53170941913085278951 -0.24402297425695182453 -0.15332069325915903546;0.05401696178464415049 -0.94627513635466709019 0.65493134437811384441 -0.095903922635229579829 0.52384699499643938569 -0.36213748206525514517;0.20992786339466923407 0.28495214981927008413 -0.39676977269798791026 -0.18992544073253042614 0.39497059146798019214 0.16780208241939598146;-0.040880352370666027395 0.29362017534642975702 0.84420497531292193472 -0.21694402085462324847 0.25336043161300864091 -0.34642041888409397243];

% Layer 2
b2 = [0.37391484975800737267;-0.027828094474193598717;0.18392433482974035464];
LW2_1 = [1.1325339941403298472 -1.2716935328489946677 0.64439157665844548628 -1.2176663482315079889 -1.9993280834987150474;0.15862603498957475456 -0.29121592504121218692 -1.2674645425943473764 -0.5513068445618810598 0.31300108827893791119;0.28097539214684885689 -0.64666242801728013312 0.38740856093089059975 -1.1065354198274193198 0.78651290645075699892];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.0211267846895733;0.0395706711489379;0.0871775967713017];
y1_step1.xoffset = [-34.05729511;-56.20691974;-10.00403908];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(3,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(3,1)];

% Allocate Outputs
y1 = zeros(3,TS);

% Time loop
for ts=1:TS

      % Rotating delay state position
      xdts = mod(ts+1,3)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[1 2]-1,3)+1),6,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[1 2]-1,3)+1),6,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
