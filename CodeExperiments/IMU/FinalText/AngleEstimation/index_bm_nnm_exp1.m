function [y1,xf1,xf2] = index_bm_nnm_exp1(x1,x2,xi1,xi2)
%INDEX_BM_NNM_EXP1 neural network simulation function.
%
% Auto-generated by MATLAB, 19-Sep-2019 16:58:57.
% 
% [y1,xf1,xf2] = index_bm_nnm_exp1(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 4xTS matrix, input #1
%   x2 = 3xTS matrix, input #2
%   xi1 = 4x2 matrix, initial 2 delay states for input #1.
%   xi2 = 3x2 matrix, initial 2 delay states for input #2.
% and returns:
%   y1 = 3xTS matrix, output #1
%   xf1 = 4x2 matrix, final 2 delay states for input #1.
%   xf2 = 3x2 matrix, final 2 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-0.395772409889456;-0.213973625786001;-0.171029829618809;-0.114024872232584];
x1_step1.gain = [2.91053271833029;4.36005106969928;6.72874898186058;10.1997260884364];
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = [-34.63462114;-56.51672659;-19.90957524];
x2_step1.gain = [0.0209968573482885;0.041868259268193;0.0430280155650301];
x2_step1.ymin = -1;

% Layer 1
b1 = [-0.0535735335262009435;0.84858987046338729687;-0.21371235810262237398;-0.11441469732099723844;0.16746065286678726847];
IW1_1 = [0.038657422144621866877 0.10143074668731487387 0.13342561027712743216 0.71654900938001964139 -0.011145136972086182314 -0.087465452741177091012 -0.14262301720844566821 -0.63937028440559906528;-0.15822105980270273484 0.57158724479508282723 0.55768533367295358705 0.64852672608968453538 -0.00076918556583008160319 -0.50523175821641752581 -0.68084800833997471958 -0.50241447123523763629;0.14642061421365037965 -0.030148613619064009578 -0.075133392042761051877 0.77041400114475377947 0.0022029456237120897781 0.0021455680303420344816 0.05188846641370303131 -0.70320776283271457796;-0.017689927580955385616 0.015913011919772648145 0.058654668396278739073 0.063121004269923022822 -0.017353754799684144305 -0.039582904163028981293 -0.084281991079880949624 -0.045257720892062966445;-0.10167346551122306841 0.12981065974218031212 0.071935619050650614903 -0.72615965383979774739 -0.048862720794254410617 -0.18019436328575155759 -0.1085915354195782917 0.6607974606661042305];
IW1_2 = [-1.4878665172642191461 0.50249135434490810326 0.47516568403406583831 1.2196208258941008129 -0.55466565603531514661 -0.65928482453013281805;-0.24555265487269303804 -0.58276885534169708958 0.80538714586076509683 0.62898163718968158609 0.54223959212301453547 -1.0213940611960776739;-1.5360801095271743311 1.7817491146336092989 0.0055313638414204065186 1.3913245035919503678 -1.4347383625077927416 -0.33987438563912919509;0.59602910779033724253 0.53720623374657772153 1.0659018584933910301 -0.14358583131870239491 -0.20330008523850995328 -0.48909415706870973395;0.092526997093295371144 -0.88194286746307526403 -1.1204184554786984496 -0.61958471000476167401 0.84744550875097635068 0.89349407522338408771];

% Layer 2
b2 = [-0.54553322038752394274;-0.13454902573844013114;0.63737046775245465025];
LW2_1 = [-1.980605465648973329 0.91719724639815769507 0.35828317095605549669 -0.5664993345665970681 -0.96383559385201522662;-0.88967275693850444984 0.46332460250104379185 1.5155390139069540023 0.91592437474526833263 1.0802083726705140609;1.7654864841257302821 -0.96744524607469872812 -1.1305678596816315373 1.3823001114211825868 0.066644966720261850091];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.0209968573482885;0.041868259268193;0.0430280155650301];
y1_step1.xoffset = [-34.63462114;-56.51672659;-19.90957524];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(4,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(3,1)];

% Allocate Outputs
y1 = zeros(3,TS);

% Time loop
for ts=1:TS

      % Rotating delay state position
      xdts = mod(ts+1,3)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[1 2]-1,3)+1),8,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[1 2]-1,3)+1),6,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
