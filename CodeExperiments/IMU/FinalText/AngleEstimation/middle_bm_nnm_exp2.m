function [y1,xf1,xf2] = middle_bm_nnm_exp2(x1,x2,xi1,xi2)
%MIDDLE_BM_NNM_EXP2 neural network simulation function.
%
% Auto-generated by MATLAB, 19-Sep-2019 16:58:55.
% 
% [y1,xf1,xf2] = middle_bm_nnm_exp2(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 4xTS matrix, input #1
%   x2 = 3xTS matrix, input #2
%   xi1 = 4x2 matrix, initial 2 delay states for input #1.
%   xi2 = 3x2 matrix, initial 2 delay states for input #2.
% and returns:
%   y1 = 3xTS matrix, output #1
%   xf1 = 4x2 matrix, final 2 delay states for input #1.
%   xf2 = 3x2 matrix, final 2 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-0.280670768920793;-0.197285173680976;-0.095713331755221;-0.091292338943629];
x1_step1.gain = [3.73961925724051;5.86224493672438;9.64016416728728;12.5337867344187];
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = [-34.05729511;-56.20691974;-10.00403908];
x2_step1.gain = [0.0211267846895733;0.0395706711489379;0.0871775967713017];
x2_step1.ymin = -1;

% Layer 1
b1 = [-0.075618909936794875826;0.078871072752570936526;0.053568280593759586006;-0.055717588349561170125;0.056729088800108649904];
IW1_1 = [-0.21032423115116277712 -0.0060581442518637760447 0.23154743299453051097 0.11147199497320557648 0.031116629614584469937 0.0027424339415954906637 -0.14349952689728379118 -0.21310859214465630029;-0.15757350146101092858 0.053213714996023370185 0.19055192205664267524 0.15461260938954066169 0.029191594557000245802 -0.025849793156531766097 -0.11648569992789335747 -0.25047404457449318205;-0.23200058330533068762 0.70776867583245850479 0.38226451560662227935 0.28667552920036831754 0.25967217783947393883 -0.61126963231373043772 -0.35951022941996901849 -0.31359141087504982526;0.22283017265137722296 -0.0048889612281081528539 -0.49476518835359956094 -0.15166521060536469756 0.14527993772739658529 0.0059679936241798965668 0.30056412205964089246 0.34311914999657300296;-0.081840419582471249371 -0.18694503344557153457 0.16561383292887191243 -0.034502755442380551865 -0.17063058337633915662 0.12711627974370010019 -0.048790964381266940797 -0.065856862114984079937];
IW1_2 = [0.20451128188675093966 -0.37054895077566513129 0.16498875991945494146 -0.10978170140219210837 0.5818844832061790262 0.10615475123432827065;0.102233813571560056 -1.0415812190651856373 0.75879980600121044176 -0.10010392198476680825 0.95620119211062470921 -0.16858409072614333191;-2.6425126067172031163 -0.85308966435660393834 0.27924436726925649932 2.6269951400773283723 0.89365087511118068697 -0.11027621392632684649;-1.2533856615884448882 1.9365366477271952483 -0.011608266665455188246 1.1446656437593429878 -1.6030630602809121665 -0.31184926723232697654;1.0150360033743388577 -0.48262895936208866088 -0.44352398179377500176 -1.2453085761423918765 0.37448061503806356898 0.36314287084251090088];

% Layer 2
b2 = [0.29651403689042593603;0.28631863449531175236;-0.085458524634535959486];
LW2_1 = [1.1080601879940006338 -1.6897732127727469464 -0.9355956042572480813 -1.8549434660238592887 -2.7986644531969342431;2.5095525878731499425 -0.42417781853948638426 -0.20234321174667854737 1.0224103651664173675 0.32056533525174668586;0.047858809398886870135 2.121610595572396285 -0.43391296653554600748 0.85124078241671341516 -0.17794121909373067369];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.0211267846895733;0.0395706711489379;0.0871775967713017];
y1_step1.xoffset = [-34.05729511;-56.20691974;-10.00403908];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(4,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(3,1)];

% Allocate Outputs
y1 = zeros(3,TS);

% Time loop
for ts=1:TS

      % Rotating delay state position
      xdts = mod(ts+1,3)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[1 2]-1,3)+1),8,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[1 2]-1,3)+1),6,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
