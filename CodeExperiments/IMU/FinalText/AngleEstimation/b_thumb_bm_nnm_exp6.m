function [y1,xf1,xf2] = thumb_bm_nnm_exp6(x1,x2,xi1,xi2)
%THUMB_BM_NNM_EXP6 neural network simulation function.
%
% Auto-generated by MATLAB, 19-Sep-2019 17:30:52.
% 
% [y1,xf1,xf2] = thumb_bm_nnm_exp6(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 6xTS matrix, input #1
%   x2 = 3xTS matrix, input #2
%   xi1 = 6x2 matrix, initial 2 delay states for input #1.
%   xi2 = 3x2 matrix, initial 2 delay states for input #2.
% and returns:
%   y1 = 3xTS matrix, output #1
%   xf1 = 6x2 matrix, final 2 delay states for input #1.
%   xf2 = 3x2 matrix, final 2 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-4.0614759468729;8.17122518427077;25.2646775604467;-4.10022324292239;6.9020664592297;24.9175021200314];
x1_step1.gain = [0.0357178119857917;0.0369756476389131;0.0596712613290543;0.0368362107940123;0.0358002095604124;0.059966120575698];
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = [-4.60253906;8.007185151;25.69303831];
x2_step1.gain = [0.0354831019441904;0.0377222788091497;0.0621721513247483];
x2_step1.ymin = -1;

% Layer 1
b1 = [0.061047611667920873013;-0.09145099364075703896;0.074562165476570685385];
IW1_1 = [0.034753517703942020389 0.017411587655006340036 0.011102195277121329822 -0.076726808698673265585 0.12559451965826845532 0.03542812469756423388 -0.025603498973177374332 -0.028397713526575763671 -0.010872794660144791123 -0.028724064523159096446 -0.076060055568574536089 0.064618988284260131527;-0.055461529670826091587 -0.089718988795301865546 0.21547036190044718817 0.203139785275972512 0.26313501673285860649 -0.10536318344807119041 -0.019378942983145623635 -0.047578186405809408388 0.045918638623102546459 -0.01773759365187381129 -0.010307478159432347659 -0.014060675349784917953;0.04043088368908593494 0.032784628453377345769 0.011822426432577911454 0.11051709710898657835 0.084552112511189880806 -0.029118297724437150475 0.025543233276575583873 0.0089939572206870592452 -0.033522568680808779995 -0.054190697349488212153 0.022530796121176779184 -0.038530237335315270508];
IW1_2 = [-0.31361396975511696139 0.38182503480888824177 0.46024182184748940738 0.23716214317726919125 -0.080000612798754505706 -0.257868285687207488;0.58275805003151959216 0.16180848707493217242 0.24469486454845945644 -0.26629102002707694119 0.018864812316619124916 -0.13506769748982402901;-0.39049365138253966379 -0.63243379101187491287 0.76937658983909285038 0.12602182765254560382 0.13991915016001832406 -0.32608221346816712582];

% Layer 2
b2 = [0.23495320323108673244;0.0226215779985849616;-0.081411507877355501761];
LW2_1 = [-1.4108073115730173086 1.7103107140283446697 0.052040643948512543826;1.4612613854676437253 0.16957889870530082344 -1.3573348864587455598;0.83566335548818360124 0.88514022068157127698 1.4951532575219019794];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.0354831019441904;0.0377222788091497;0.0621721513247483];
y1_step1.xoffset = [-4.60253906;8.007185151;25.69303831];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(6,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(3,1)];

% Allocate Outputs
y1 = zeros(3,TS);

% Time loop
for ts=1:TS

      % Rotating delay state position
      xdts = mod(ts+1,3)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[1 2]-1,3)+1),12,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[1 2]-1,3)+1),6,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
