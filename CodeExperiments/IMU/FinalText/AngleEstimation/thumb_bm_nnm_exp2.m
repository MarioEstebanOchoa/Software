function [y1,xf1,xf2] = thumb_bm_nnm_exp2(x1,x2,xi1,xi2)
%THUMB_BM_NNM_EXP2 neural network simulation function.
%
% Auto-generated by MATLAB, 19-Sep-2019 16:59:22.
% 
% [y1,xf1,xf2] = thumb_bm_nnm_exp2(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 3xTS matrix, input #1
%   x2 = 3xTS matrix, input #2
%   xi1 = 3x2 matrix, initial 2 delay states for input #1.
%   xi2 = 3x2 matrix, initial 2 delay states for input #2.
% and returns:
%   y1 = 3xTS matrix, output #1
%   xf1 = 3x2 matrix, final 2 delay states for input #1.
%   xf2 = 3x2 matrix, final 2 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-0.417033374379435;-0.233340177699225;-0.152979659687625];
x1_step1.gain = [3.24426026057652;4.16098014524691;6.45037721182388];
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = [-4.60253906;8.007185151;25.69303831];
x2_step1.gain = [0.0354831019441904;0.0377222788091497;0.0621721513247483];
x2_step1.ymin = -1;

% Layer 1
b1 = [0.26876143521372575229;0.06810304807630622459;0.22973062288417261945;0.073479243328584811779;0.038767758451076550497];
IW1_1 = [-1.007359431005045991 -0.62161184429742544211 0.021637962861136401937 0.88319405669389339231 0.27877007680841997539 0.14610930771665228689;-0.55148740188257372452 -0.16590570749512778548 0.071126931578237545528 0.50946059837267521075 0.10670979716143541571 -0.10121798832733906737;-0.49696832133838830803 -0.24543711884257712885 0.010114207701577738671 0.40277973517327969599 0.032417958987719229513 0.068352172414887973906;1.7075814686327344116 -0.52432315517538796712 0.0028607406198545661836 -1.7358558975151596737 0.16846836632338574313 0.38034456476237255007;1.0750702234561722026 -0.22247517662201229949 -0.031381450297354666901 -1.0730269870135258348 0.06976617770633694593 0.21739783851889737942];
IW1_2 = [-2.5913919238681253354 0.3001059444648460639 -0.22090428395968145225 2.0600385776402978522 -0.63847529801524749438 0.44802371487798631211;0.11533023928217296661 0.026431446261133362263 -0.015301264058965419537 0.063727937351252816889 -0.17393411403734931886 0.23378534256903760191;-0.64231739693411871173 0.18577030110635456284 -0.60965908141107916229 0.74026900418274454996 -0.45385636339056811828 0.48870650497994333472;-2.4670233626621573819 -0.98569529680149114981 1.0167328984603261066 2.1062362332774244855 0.67788485936579234714 -0.96676411327890054981;-1.527052084348124783 -1.0313509226999049151 1.1669030203929919853 1.1943879633263032591 0.6235392412879314783 -0.88090290487022160359];

% Layer 2
b2 = [-0.0029415785330413417829;0.28017460636733160229;0.17653929388219952168];
LW2_1 = [-1.075647135861425685 2.1383711807181335907 0.60192804904219776585 0.88575865919528362635 -0.74504703478603939715;0.80128363302150229508 1.6592417588392460726 -2.8254769611037930943 2.180648592311469347 -3.5550708120230427589;0.35678291808016315834 3.2344385172625478297 -2.4416312215953333009 0.85953712280764837939 -0.53038782706582787707];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.0354831019441904;0.0377222788091497;0.0621721513247483];
y1_step1.xoffset = [-4.60253906;8.007185151;25.69303831];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(3,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(3,1)];

% Allocate Outputs
y1 = zeros(3,TS);

% Time loop
for ts=1:TS

      % Rotating delay state position
      xdts = mod(ts+1,3)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[1 2]-1,3)+1),6,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[1 2]-1,3)+1),6,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
