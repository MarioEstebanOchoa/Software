function [y1,xf1,xf2] = thumb_bm_nnm_exp1(x1,x2,xi1,xi2)
%THUMB_BM_NNM_EXP1 neural network simulation function.
%
% Auto-generated by MATLAB, 13-Sep-2019 14:49:22.
% 
% [y1,xf1,xf2] = thumb_bm_nnm_exp1(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 3xTS matrix, input #1
%   x2 = 3xTS matrix, input #2
%   xi1 = 3x2 matrix, initial 2 delay states for input #1.
%   xi2 = 3x2 matrix, initial 2 delay states for input #2.
% and returns:
%   y1 = 3xTS matrix, output #1
%   xf1 = 3x2 matrix, final 2 delay states for input #1.
%   xf2 = 3x2 matrix, final 2 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-0.236974178704311;-0.190831839101213;-0.173401523568524];
x1_step1.gain = [3.47269730142813;5.46221592347734;6.35178921915196];
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = [-4.60253906;8.007185151;25.69303831];
x2_step1.gain = [0.0354831019441904;0.0377222788091497;0.0621721513247483];
x2_step1.ymin = -1;

% Layer 1
b1 = [0.1756856677968026692;0.22953926786915257452;-0.055395488208559558185;0.032934208856386079645;-0.3198208368644843147];
IW1_1 = [0.49175483666994734833 -0.15092675070802832882 -0.73930754256673991698 -0.39216447244614488499 -0.38908978915806341492 0.85350961159926286292;-0.79315721112186310382 0.38625426117788230762 0.88255484255793181791 0.44546545931832742804 0.35888671255230347734 -1.126694247526008219;0.45549588803173246543 0.66973083544551770263 -2.0168455251868331324 -0.79376242962740839459 -0.95461313542164216717 1.896542528008944295;0.052332399644259244842 0.21569208463186698155 -0.52432841947709196706 -0.21813234580415727382 -0.36243736165906326185 0.49004857543209584536;0.52955999025448519113 -0.67162361273556725472 0.22787653847197122947 -0.14173913299216078787 0.087151580590018346006 -0.0099522565269686419365];
IW1_2 = [0.18792146389798966566 0.68584497693441537347 0.52971040013647208156 0.11092575162051385163 -0.49509779259629621562 -0.82137024424492044439;-0.43140150734866977711 -1.9508376778773424132 0.40287405467067438636 -0.12335320492747664511 1.1917361931656362817 0.57546375429167206939;2.9662122223511202534 -0.16041220321097582335 0.23883494185228279494 -2.2209960015794898425 0.26970627225360699342 -0.4837896544095324769;0.66118037459382739129 -0.06923841000691359493 0.78232523046183610749 -0.4525614819684611323 0.22555487638209947843 -0.45871641613404723348;-0.82401371453705729575 1.2069637738585274889 0.411361526722633708 1.3824010987836177211 -0.96611997286207773605 -0.73774890652683311476];

% Layer 2
b2 = [0.95203824039951645553;0.4049505514853745658;0.038603836599716938316];
LW2_1 = [-2.3515659209752755032 0.24738109775295383241 1.1523472759709278979 0.11152549498946226492 1.7078639012992375967;-1.8855792294144981813 -1.7816437863577772038 -0.82849381949497691302 2.1792274749689903857 -0.57807216430886121383;-0.21820656125320989083 0.51619983106575006993 -0.22870021519481950611 1.6571997570705601088 0.68675553695109003982];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.0354831019441904;0.0377222788091497;0.0621721513247483];
y1_step1.xoffset = [-4.60253906;8.007185151;25.69303831];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(3,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(3,1)];

% Allocate Outputs
y1 = zeros(3,TS);

% Time loop
for ts=1:TS

      % Rotating delay state position
      xdts = mod(ts+1,3)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[1 2]-1,3)+1),6,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[1 2]-1,3)+1),6,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
