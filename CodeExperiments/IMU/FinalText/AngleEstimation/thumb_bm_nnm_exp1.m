function [y1,xf1,xf2] = thumb_bm_nnm_exp1(x1,x2,xi1,xi2)
%THUMB_BM_NNM_EXP1 neural network simulation function.
%
% Auto-generated by MATLAB, 19-Sep-2019 16:59:22.
% 
% [y1,xf1,xf2] = thumb_bm_nnm_exp1(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 3xTS matrix, input #1
%   x2 = 3xTS matrix, input #2
%   xi1 = 3x2 matrix, initial 2 delay states for input #1.
%   xi2 = 3x2 matrix, initial 2 delay states for input #2.
% and returns:
%   y1 = 3xTS matrix, output #1
%   xf1 = 3x2 matrix, final 2 delay states for input #1.
%   xf2 = 3x2 matrix, final 2 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-0.236974178704311;-0.190831839101213;-0.173401523568524];
x1_step1.gain = [3.47269730142813;5.46221592347734;6.35178921915196];
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = [-4.60253906;8.007185151;25.69303831];
x2_step1.gain = [0.0354831019441904;0.0377222788091497;0.0621721513247483];
x2_step1.ymin = -1;

% Layer 1
b1 = [-0.27517347499506367159;-0.41189119093259979332;-0.087496365982524845761;-0.16108523452993087077;-0.34950099682879365304];
IW1_1 = [0.030487391814552827068 -0.20081669541523489153 0.46350374042673558872 -0.11150260538731193716 -0.031214226151694949435 -0.074290606495262576092;0.80836297279064650567 -0.48530219719762734965 -1.6625780988775222813 -0.64639348079357050736 -0.65068182905386529047 1.5183621062803123181;0.20071518998619117258 -0.17418751328875603512 -0.26641335737078375434 -0.12855880520885443197 -0.10983077666320950616 0.37215212487167070865;0.4194881319873137171 -0.35289006966398922538 -0.74171132867564482094 -0.34773188120759251918 -0.40737218507908423692 0.74439822639575126129;0.58312199848637369382 -0.55810326172343516227 -0.74403587578697827354 -0.46055873011498849046 -0.45260810883578617148 1.0583036015379447825];
IW1_2 = [-0.43385557049528344908 1.5412645193555127854 0.56901253748261848564 0.76920268648903566966 -2.0692355452472956934 -0.80861077880419096608;3.1127385078484097747 -0.65189693889114286307 0.10624570266287845788 -1.5960876556395275916 1.8201349049180499673 -0.91972134656068005309;0.76871081402823993045 0.78029384305560844926 -0.56368354219057248411 -0.3887717701633032763 -0.34556574087658137318 -0.031685327979988076041;1.3162552603803208129 0.031417743542255169298 0.6926414070925119848 -0.49471077710137700834 0.77318254513720474641 -0.90696861998512323666;1.1532217868465770572 1.5154472947908095293 0.02857674757721516412 -0.34964675080071461188 -0.78223116541440429472 -1.1174362301502736017];

% Layer 2
b2 = [0.17476753196229924403;-0.3617944812960149914;-0.11126609807092703586];
LW2_1 = [1.3033362319563939202 0.7733885674404159527 2.0335285057496403915 0.4730051641799678519 -2.1390267139726346635;-0.51475028195089833627 -1.5114759352819142624 2.6560648856662263384 2.1981840950638469323 -0.60094998754490591697;0.46506626863523675697 -0.49993928051276587121 -0.26650590264280404895 1.8867593477589135187 -0.81836625042017696607];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.0354831019441904;0.0377222788091497;0.0621721513247483];
y1_step1.xoffset = [-4.60253906;8.007185151;25.69303831];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(3,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(3,1)];

% Allocate Outputs
y1 = zeros(3,TS);

% Time loop
for ts=1:TS

      % Rotating delay state position
      xdts = mod(ts+1,3)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[1 2]-1,3)+1),6,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[1 2]-1,3)+1),6,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
