function [y1,xf1,xf2] = thumb_bm_nnm_exp2(x1,x2,xi1,xi2)
%THUMB_BM_NNM_EXP2 neural network simulation function.
%
% Auto-generated by MATLAB, 13-Sep-2019 14:55:59.
% 
% [y1,xf1,xf2] = thumb_bm_nnm_exp2(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 3xTS matrix, input #1
%   x2 = 3xTS matrix, input #2
%   xi1 = 3x2 matrix, initial 2 delay states for input #1.
%   xi2 = 3x2 matrix, initial 2 delay states for input #2.
% and returns:
%   y1 = 3xTS matrix, output #1
%   xf1 = 3x2 matrix, final 2 delay states for input #1.
%   xf2 = 3x2 matrix, final 2 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-0.417033374379435;-0.233340177699225;-0.152979659687625];
x1_step1.gain = [3.24426026057652;4.16098014524691;6.45037721182388];
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = [-4.60253906;8.007185151;25.69303831];
x2_step1.gain = [0.0354831019441904;0.0377222788091497;0.0621721513247483];
x2_step1.ymin = -1;

% Layer 1
b1 = [0.18044883536410624703;-0.25003189018174198921;-0.039508316084236327903;0.096688386099172685118;-0.22628359950391713218];
IW1_1 = [-0.52158226721189826502 -0.15247121328742321844 -0.15304350799901128566 0.46153284558741486387 0.02307521355083826109 0.23790360812575761518;0.99213878568453583995 0.38929440744199245161 0.2577359138628747548 -0.88968999235526058378 -0.046302627274614371888 -0.39170261074777307231;0.65762905384818448606 0.2837026003462912449 0.16349042474637953681 -0.53709130572775121149 0.10618530754576988029 -0.283073371339610802;0.85783052276638382949 0.11865253152248267376 0.15998583656357762139 -0.85982172108708321279 -0.34449828387559217058 -0.31200892027938303963;-0.31503812970531153148 -0.38139280080280735241 0.013508439173835430983 0.20447440536374131281 -0.065552369800867552052 0.056550552201377113359];
IW1_2 = [-0.56163850477988586096 0.29765131805302397217 -0.35135013624713828939 0.55104692556553325211 -0.54810965974847580817 0.33443512913705164546;2.0713708326830295725 -0.031121854201498461157 0.27307093616804550829 -1.5626477353036829498 0.49019839030086115317 -0.48560551681674590796;0.84369573703332079173 -0.27742592718534392349 1.2697645052929469323 -0.89719260132548162012 0.45920443259522608637 -0.93690213923126153261;-0.30046322337542386016 -2.3986585907199953205 0.88555090858020968358 0.13436546846972943769 1.8698959302431201746 -0.56232127832933886946;-0.31358284723463669685 -0.17545254667188125985 -0.92651954598248131845 0.6189876993931033855 0.11750353106730623831 0.76884816576461190163];

% Layer 2
b2 = [0.1730630408955306232;0.74349367404775457135;0.258573174441074638];
LW2_1 = [2.9418991883672078735 1.2552336347486934276 1.3405134580488207163 0.2062548114470555416 1.470537591019141388;-3.4614412675728618574 -1.2482560708140959527 0.76480801432179090771 -1.2469808661838641672 1.3699182962225870952;0.89018660923273884578 -1.0420722828196757881 3.6285605391144133414 -0.29113872509842192438 2.3779843442195187642];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.0354831019441904;0.0377222788091497;0.0621721513247483];
y1_step1.xoffset = [-4.60253906;8.007185151;25.69303831];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(3,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(3,1)];

% Allocate Outputs
y1 = zeros(3,TS);

% Time loop
for ts=1:TS

      % Rotating delay state position
      xdts = mod(ts+1,3)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[1 2]-1,3)+1),6,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[1 2]-1,3)+1),6,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
