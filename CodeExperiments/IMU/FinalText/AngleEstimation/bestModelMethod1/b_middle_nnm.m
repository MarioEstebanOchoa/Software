function [y1,xf1,xf2] = middle_nnm(x1,x2,xi1,xi2)
%MIDDLE_NNM neural network simulation function.
%
% Auto-generated by MATLAB, 27-Aug-2019 15:25:06.
% 
% [y1,xf1,xf2] = middle_nnm(x1,x2,xi1,xi2) takes these arguments:
%   x1 = 8xTS matrix, input #1
%   x2 = 3xTS matrix, input #2
%   xi1 = 8x2 matrix, initial 2 delay states for input #1.
%   xi2 = 3x2 matrix, initial 2 delay states for input #2.
% and returns:
%   y1 = 3xTS matrix, output #1
%   xf1 = 8x2 matrix, final 2 delay states for input #1.
%   xf2 = 3x2 matrix, final 2 delay states for input #2.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-0.4931;-0.087;0.7581;-0.447;-0.4389;-0.0141;0.8263;0.1727];
x1_step1.gain = [5.12689054088695;4.46428571428571;9.00900900900901;2.20264317180617;8.68432479374729;9.14913083257091;16.0901045856798;8.09061488673139];
x1_step1.ymin = -1;

% Input 2
x2_step1.xoffset = [-42.35398667;-27.72971757;-11.74116906];
x2_step1.gain = [0.0198931201438839;0.0425556129037359;0.0519258024025963];
x2_step1.ymin = -1;

% Layer 1
b1 = [-0.016970504215291989936;0.0082302144764257838261;0.011894806795942652888];
IW1_1 = [-0.08173554902904396624 0.020382792942570834155 0.11098640432891118679 -0.078838927103436734489 0.02540320262782260613 0.049343366037040509164 0.16914363456707348643 0.060821784511204492196 0.094802327941332933947 0.0010456124084655847237 -0.10435077897883056341 0.010316683674889338962 -0.011310293873369806072 -0.076726416627185767272 -0.20489179978390187342 -0.058134241398155601932;-0.0063098912746253300529 0.061603929904583472343 0.011870142720971589914 -0.039984254099569960239 -0.04164371560222457358 -0.11083687627708047052 0.0097281345641020266352 0.081441654718762482301 0.012500473218586142035 -0.071480105845794311703 -0.01636183258982942465 0.043145835296469224607 0.062242299199623242478 0.075497335203519824742 -0.037961699999260502258 -0.092448721332950081764;-0.063436079893432084642 -0.1094602266185190631 0.0026137318956222107234 0.069827417757419532607 -0.024592607285766669711 0.0028181141650954924342 0.14354589261623376673 0.10463015134192081568 0.060048483165918049853 0.1036443258597862932 -0.019466293196349373357 -0.054516684701422277182 0.014183018811700153633 0.043785484295021326329 -0.17835695033892332018 -0.14356365182119970592];
IW1_2 = [1.0693297794218834529 -0.14820402362180118416 0.18360133238435163983 -0.4858861918774576294 0.12091994695295832374 -0.05141525446108991676;-0.51476046732849967125 0.55517618045552941108 0.91209671729052899103 0.21873093607609442324 -0.1544255465922327597 -0.3751176101768577964;0.082958494387664324932 0.72476238438970619349 -0.44209180495600869376 -0.069335171440040796464 -0.27370718829536572203 0.35237309500469299328];

% Layer 2
b2 = [0.027011731687435317634;0.0020806512822196827212;-0.0011104545014569301015];
LW2_1 = [1.6722464649082084964 -0.30209131054284366069 0.37710139407461001904;0.14858778466176628119 0.41965188420966320626 1.6724523742678520932;0.77011943863377019248 1.3080226308406583957 -0.92266648428546782501];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = [0.0198931201438839;0.0425556129037359;0.0519258024025963];
y1_step1.xoffset = [-42.35398667;-27.72971757;-11.74116906];

% ===== SIMULATION ========

% Dimensions
TS = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(8,1)];

% Input 2 Delay States
xd2 = mapminmax_apply(xi2,x2_step1);
xd2 = [xd2 zeros(3,1)];

% Allocate Outputs
y1 = zeros(3,TS);

% Time loop
for ts=1:TS

      % Rotating delay state position
      xdts = mod(ts+1,3)+1;
    
    % Input 1
    xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
    
    % Input 2
    xd2(:,xdts) = mapminmax_apply(x2(:,ts),x2_step1);
    
    % Layer 1
    tapdelay1 = reshape(xd1(:,mod(xdts-[1 2]-1,3)+1),16,1);
    tapdelay2 = reshape(xd2(:,mod(xdts-[1 2]-1,3)+1),6,1);
    a1 = tansig_apply(b1 + IW1_1*tapdelay1 + IW1_2*tapdelay2);
    
    % Layer 2
    a2 = b2 + LW2_1*a1;
    
    % Output 1
    y1(:,ts) = mapminmax_reverse(a2,y1_step1);
end

% Final delay states
finalxts = TS+(1: 2);
xits = finalxts(finalxts<=2);
xts = finalxts(finalxts>2)-2;
xf1 = [xi1(:,xits) x1(:,xts)];
xf2 = [xi2(:,xits) x2(:,xts)];
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
  y = bsxfun(@minus,x,settings.xoffset);
  y = bsxfun(@times,y,settings.gain);
  y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
  a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
  x = bsxfun(@minus,y,settings.ymin);
  x = bsxfun(@rdivide,x,settings.gain);
  x = bsxfun(@plus,x,settings.xoffset);
end
